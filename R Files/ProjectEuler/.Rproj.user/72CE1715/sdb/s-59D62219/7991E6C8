{
    "collab_server" : "",
    "contents" : "#' Checks to see if a value in the unit interval\n#'\n#' If a value between 0 and 1 inclusive this will return a true booleon\n#'\n#' @param x A numeric value to check\n#'\n#' @return Boolean value\n#' @export\nunitValue <- function(x) {\n\t0 <= x && x <= 1\n}\n\n#' Splits a number into a string of digits\n#'\n#' @param number A number to convert to digits\n#'\n#' @return\n#' @export\n#'\n#' @examples\nstringDigits <- function(number){\n\tunlist(strsplit(as.character(number),\"\"))\n}\n\n#' Get numerical digits of a number through strings\n#'\n#' This converts the number to a string, splitting the string then converting back to a number\n#'\n#' @param number Number to get numerical digits of\n#'\n#' @return Named array of digits\n#' @export\n#'\n#' @examples\n#' getDigitsStrSplit(123)\ngetDigitsStrSplit <- function(number) {\n\tsapply(stringDigits(number), as.numeric)\n}\n\n#' Compare two numbers digits\n#'\n#' If two numbers have the same digits this function will return a true statement\n#'\n#' Used in Euler 52\n#'\n#' @param first.number First numeric to compare\n#' @param second.number Second numeric to compare\n#'\n#' @return Boolean\n#' @export\n#'\n#' @examples\ndigitMatch <- function(first.number, second.number) {\n\tall(stringDigits(first.number) %in% stringDigits(second.number)) && all(stringDigits(second.number) %in% stringDigits(first.number))\n}\n\n\n#' Find a hidden arithmetic sequence\n#'\n#' Given a sequence of sorted numbers this function will see if there are combinations of numbers\n#' which can form an arithmetic sequence. The first found sequence will be returned.\n#'\n#' Used in Euler 49\n#'\n#' @param x Vector of numbers\n#' @param seq.length Minimum sequence length\n#'\n#' @return\n#' @export\n#'\n#' @examples\n#' findArithmeticSeq(c(5,1,6,9,2,3,4,5,6,7,8,9), 3)\nfindArithmeticSeq <- function(x, seq.length = 3) {\n\n\t# Quick asserts\n\tif (seq.length <= 2) stop(\"seq.length must be greater than 2\")\n\tif (!is.numeric(x)) stop(\"x must be numeric\")\n\tif (length(x) <= 2) stop(\"The length of x must be greater or equal to 2\")\n\n\t# Set key parameters\n\tn <- length(x)\n\tcount <- 0\n\tstart <- 1\n\n\t# Loop to find the start of the sequence\n\twhile (count < seq.length && start < n) {\n\n\t\t# Loop to find a matching sequence\n\t\tfor (i in (start + 1):n) {\n\n\t\t\t# Find the difference\n\t\t\tstep <- x[i] - x[start]\n\n\t\t\t# Need positive integer steps\n\t\t\tif (step < 1) next\n\n\t\t\t# Generate the sequence\n\t\t\texp.seq <- seq(x[start], x[n] + 1,step)\n\n\t\t\t# See if the expected values match the collection of numbers\n\t\t\tmatches <- x %in% exp.seq\n\n\t\t\t# Calculate the var of differences, and check of NA's\n\t\t\tvar.of.diff <- var(diff(x[matches]))\n\t\t\tif (is.na(var.of.diff)) next\n\n\t\t\t# Assert that the matches themselves are an arithmetic sequence\n\t\t\tif (sum(matches) == seq.length && var.of.diff == 0) {\n\t\t\t\tcount <- sum(matches)\n\t\t\t\tbreak\n\t\t\t}\n\n\t\t}\n\n\t\t# See if a sufficient sequence has been found\n\t\tif (count == seq.length) {\n\t\t\treturn(x[matches])\n\t\t}\n\n\t\t# Increment the starting index\n\t\tstart <- start + 1\n\n\t}\n\n\t# If there is no sequence return null\n\tNULL\n\n}\n\n#' Get the number of digits in a number\n#'\n#' Will return the number of digits in a number\n#'\n#' @param x Positive integer\n#'\n#' @return\n#' @export\n#'\n#' @examples\n#' digits(123)\ndigits <- function(x) {\n\trem <- x\n\ttotal <- 0\n\twhile(rem >= 1) {\n\t\trem <- rem/10\n\t\ttotal <- total + 1\n\t}\n\ttotal\n}\n\n#' Get the digits of a number\n#'\n#' Returns a numeric vector of an integers digits.\n#'\n#' @param x An integer\n#'\n#' @return An integer array\n#' @export\n#'\n#' @examples\n#' getDigits(123)\ngetDigits <- function(x) {\n\tdigits <- c()\n\twhile (x >= 1) {\n\t\tdigits <- append(x %% 10, digits)\n\t\tx <- floor(x/10)\n\t}\n\n\tdigits\n\n}\n\n#' Bind digits to number\n#'\n#' Given a numeric vector of digits this function will return the number\n#'\n#' @param x Numeric vector\n#'\n#' @return Number\n#' @export\n#'\n#' @examples\n#' bindDigits(c(1,2,3,4))\nbindDigits <- function(x) {\n\toutput <- 0\n\tmultiple <- 1\n\n\tfor (i in rev(x)) {\n\t\toutput <- output + (multiple*i)\n\t\tmultiple <- multiple*10\n\t}\n\n\toutput\n}\n\n#' Check if integer is palindrom\n#'\n#' Checks if an integer is a palindrome\n#'\n#' @param x Integer number\n#'\n#' @return Boolean\n#' @export\n#'\n#' @examples\n#' isPalindrome(1234)\n#' isPalindrome(12344)\nisPalindrome <- function(x) {\n\n\t# Split number and get digits\n\tdigits <- as.numeric(unlist(strsplit(as.character(x),\"\")))\n\tn <- length(digits)\n\n\t# Check all digits are there\n\tfor (i in 1:n) {\n\t\tif(!i %in% digits) return(F)\n\t}\n\n\t# Return true if test passes\n\treturn(T)\n}\n\n#' Get next lexicographical permutation of list\n#'\n#' Given a list, this function can iteratively find every permutation of the list in\n#' lexicographic order.\n#'\n#' @param x Numeric vector\n#' @param direction \"UP\" or \"DOWN\"\n#' @param find.all For internal use in allPermutations\n#'\n#' @return Numeric Vector\n#' @export\n#'\n#' @examples\n#' permutate(c(1,2,3), \"UP\")\n#' permutate(permutate(c(1,2,3), \"UP\"))\npermutate <- function(x, direction = \"UP\", find.all = F) {\n\n\t# Basic setup\n\tup <- direction == \"UP\"\n\tn <- length(x)\n\tk <- NULL\n\tl <- NULL\n\n\t# Comparing function\n\tcompare <- ifelse(up, `<`, `>`)\n\n\n\t# Quick checks\n\tif (n < 1) stop(\"x must be longer than 1\")\n\n\t# Find K\n\tfor (i in (n-1):1) {\n\t\tif (compare(x[i], x[i + 1])) {\n\t\t\tk <- i\n\t\t\tbreak\n\t\t}\n\t}\n\n\tif (is.null(k) && !find.all){\n\t\tstop(\"No further perumtations\")\n\t} else if (is.null(k)) {\n\t\treturn(NULL)\n\t}\n\n\t# Find l\n\tfor (i in n:1) {\n\t\tif (compare(x[k], x[i])) {\n\t\t\tl <- i\n\t\t\tbreak\n\t\t}\n\t}\n\n\t# Make the update\n\tholder <- x[l]\n\tx[l] <- x[k]\n\tx[k] <- holder\n\n\tto.rev <- (k + 1):n\n\n\tif (length(to.rev) > 0) x[to.rev] <- x[rev(to.rev)]\n\n\tx\n}\n\n#' Get all digit permutations of a number\n#'\n#' This function finds all digit permutations of a number in lexicographical order. That\n#' order is defined by direction. Note that this is done incrementally, so \\code{allPermutations(1234,\"DOWN\")}\n#' will only return 1234.\n#'\n#' @param x Number whos digits permutations should be found\n#' @param direction Direction of permutation\n#'\n#' @return\n#' @export\n#'\n#' @examples\nallPermutations <- function(x, direction = \"UP\") {\n\toutput <- c()\n\n\tgetNext <- function(x) {\n\t\tx <- permutate(getDigits(x),find.all = T, direction = direction)\n\t\tif (is.null(x)) return(x)\n\t\tbindDigits(x)\n\t}\n\n\twhile (!is.null(x)) {\n\t\toutput <- append(output, x)\n\t\tx <- getNext(x)\n\t}\n\n\toutput\n\n}\n\n#' Calculate the sum of viable divisors\n#'\n#' This function tallys the sum of divisors for a number.\n#'\n#' @param x Integer\n#'\n#' @return\n#' @export\n#'\n#' @examples\n#' sumOfDivisors(25)\nsumOfDivisors <- function(x) {\n\tsum <- 0\n\ti <- 1\n\tfor(i in 1:(0.5*x)) {\n\t\tif(x%%i == 0) {\n\t\t\tsum <- sum + i\n\t\t}\n\t}\n\tsum\n}\n",
    "created" : 1487006145799.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "904128268",
    "id" : "7991E6C8",
    "lastKnownWriteTime" : 1487175755,
    "last_content_update" : 1487175755123,
    "path" : "~/Documents/ProjectEuler/R Files/ProjectEuler/R/BasicUtilities.R",
    "project_path" : "R/BasicUtilities.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 6,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}